  /// \file xdrlcio_test_calohit.cc
/*
 *
 * xdrlcio_test_calohit.cc source template automatically generated by a class generator
 * Creation date : mer. fï¿½vr. 17 2016
 *
 * This file is part of xdrlcio libraries.
 * 
 * xdrlcio is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * xdrlcio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with xdrlcio.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- std headers
#include <ctime>
#include <iostream>

// -- xdrstream headers
#include "xdrstream/BufferDevice.h"

// -- xdrlcio headers
#include "xdrlcio/XdrLcio.h"

// -- lcio headers
#include "IMPL/CalorimeterHitImpl.h"
#include "IMPL/LCCollectionVec.h"
#include "IMPL/LCEventImpl.h"
#include "IMPL/LCFlagImpl.h"
#include "UTIL/LCTOOLS.h"

#define CH_TEST_RETURN( Command ) \
{ \
xdrstream::Status status = Command; \
if( status != xdrstream::XDR_SUCCESS ) \
{ \
	std::cout << "Error caught line " << __LINE__ << " of command " << #Command << std::endl; \
	xdrstream::printStatus( status ); \
	return status; \
} \
}

static const uint32_t nCaloHits = 20;

void fillCaloHitCollection(EVENT::LCCollection *pLCCollection);

int main(int argc, char **argv)
{
	// xdr buffer
	std::cout << "Creating out buffer" << std::endl;
	xdrstream::BufferDevice *pOutDevice = new xdrstream::BufferDevice(1024*1024); // 1 Mo to start

	// lcio main interface
	std::cout << "Creating xdrlcio interface" << std::endl;
	xdrlcio::XdrLcio *pXdrLcio = new xdrlcio::XdrLcio();

	// create an event and a collection
	std::cout << "Creating lc event" << std::endl;
	IMPL::LCEventImpl *pLCEvent = new IMPL::LCEventImpl();
	pLCEvent->setEventNumber( time(0) );
	pLCEvent->setRunNumber( 42 );

	std::cout << "Creating lc collection" << std::endl;
	IMPL::LCCollectionVec *pLCCollection = new IMPL::LCCollectionVec(EVENT::LCIO::CALORIMETERHIT);

	IMPL::LCFlagImpl lcFlag;
	lcFlag.setBit(EVENT::LCIO::RCHBIT_LONG);
	lcFlag.setBit(EVENT::LCIO::RCHBIT_TIME);
	lcFlag.setBit(EVENT::LCIO::RCHBIT_ENERGY_ERROR);
	pLCCollection->setFlag(lcFlag.getFlag());

	pLCEvent->addCollection(pLCCollection, "TestCaloHits");

	std::cout << "Creating calo hits" << std::endl;
	fillCaloHitCollection(pLCCollection);

	std::cout << "Dumping write event" << std::endl;
	UTIL::LCTOOLS::dumpEventDetailed( pLCEvent );

	std::cout << "Writting lc event to buffer" << std::endl;
	CH_TEST_RETURN( pXdrLcio->writeEvent( pLCEvent, pOutDevice ) )

	std::cout << "Deleting lc event" << std::endl;
	delete pLCEvent;

	std::cout << "Creating in buffer" << std::endl;
	xdrstream::BufferDevice *pInDevice = new xdrstream::BufferDevice(pOutDevice->getBuffer() , pOutDevice->getPosition(), false); // 1 Mo to start
	pInDevice->setOwner(false);

	std::cout << "Reading event in buffer" << std::endl;
	CH_TEST_RETURN( pXdrLcio->readNextEvent( pInDevice ) )

	EVENT::LCEvent *pReadLCEvent = pXdrLcio->getLCEvent();
	std::cout << "Event address : " << pReadLCEvent << std::endl;

	std::cout << "Dumping read event" << std::endl;
	UTIL::LCTOOLS::dumpEventDetailed( pReadLCEvent );

	std::cout << "Deleting xdrlcio" << std::endl;
	delete pXdrLcio;

	std::cout << "Deleting devices" << std::endl;
	delete pOutDevice;
	delete pInDevice;

	return 0;
}

//----------------------------------------------------------------------------------------------------

void fillCaloHitCollection(EVENT::LCCollection *pLCCollection)
{
	for( uint32_t i=0 ; i<nCaloHits ; i++ )
	{
		IMPL::CalorimeterHitImpl *pCaloHit = new IMPL::CalorimeterHitImpl();

		pCaloHit->setCellID0(123*i);
		pCaloHit->setCellID1(456*i);

		pCaloHit->setEnergy(0.1 * i);
		pCaloHit->setEnergyError( 0.001 * i );

		pCaloHit->setTime(10 * i);

		float position[3];
		position[0] = 10.0 * i;
		position[1] = - 10.0 * i;
		position[2] = 2.67 * i;
		pCaloHit->setPosition(position);

		pLCCollection->addElement(pCaloHit);
	}
}
