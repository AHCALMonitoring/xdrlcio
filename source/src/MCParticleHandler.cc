  /// \file MCParticleHandler.cc
/*
 *
 * MCParticleHandler.cc source template automatically generated by a class generator
 * Creation date : sam. fï¿½vr. 20 2016
 *
 * This file is part of xdrlcio libraries.
 * 
 * xdrlcio is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * xdrlcio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with xdrlcio.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "xdrlcio/MCParticleHandler.h"

#include "IOIMPL/MCParticleIOImpl.h"
#include "IMPL/LCFlagImpl.h"
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"

namespace xdrlcio
{

class XdrMCParticle : public IOIMPL::MCParticleIOImpl
{
	friend class MCParticleHandler;
};

//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------

xdrstream::Status MCParticleHandler::read(xdrstream::IODevice *pDevice, EVENT::LCObject *&pLCObject)
{
	XdrMCParticle *pMCParticle = new XdrMCParticle();
	pLCObject = pMCParticle;

	XDR_STREAM( pDevice->readPointerTag((void *) pMCParticle) )

	uint32_t nParents;
	XDR_STREAM( pDevice->read( & nParents ) )

	pMCParticle->_parents.resize( nParents );

	for( uint32_t i=0 ; i<nParents ; i++ )
		XDR_STREAM( pDevice->readPointerReference( (void **) & pMCParticle->_parents[i] ) )

	XDR_STREAM( pDevice->read<int32_t>( & pMCParticle->_pdg ) )
	XDR_STREAM( pDevice->read<int32_t>( & pMCParticle->_genstatus ) )

	int32_t simstatus;
	XDR_STREAM( pDevice->read<int32_t>( & simstatus ) )
	pMCParticle->_simstatus = simstatus;

	XDR_STREAM( pDevice->readStaticArray( pMCParticle->_vertex , 3 ) )
	XDR_STREAM( pDevice->read( & pMCParticle->_time ) )
	XDR_STREAM( pDevice->readStaticArray( pMCParticle->_p, 3 ) )
	XDR_STREAM( pDevice->read( & pMCParticle->_mass ) )
	XDR_STREAM( pDevice->read( & pMCParticle->_charge ) )

	if( pMCParticle->_simstatus.test( EVENT::MCParticle::BITEndpoint ) )
		XDR_STREAM( pDevice->readStaticArray( pMCParticle->_endpoint , 3 ) )

	XDR_STREAM( pDevice->readStaticArray( pMCParticle->_spin , 3 ) )
	XDR_STREAM( pDevice->readStaticArray<int32_t>( pMCParticle->_colorFlow , 2 ) )

	return xdrstream::XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

xdrstream::Status MCParticleHandler::write(xdrstream::IODevice *pDevice, const EVENT::LCObject *const pLCObject)
{
	const EVENT::MCParticle *const pMCParticle = dynamic_cast<const EVENT::MCParticle *const>( pLCObject );

	XDR_STREAM( pDevice->writePointerTag( pMCParticle ) )

	uint32_t nParents = pMCParticle->getParents().size();
	XDR_STREAM( pDevice->write( & nParents ) )

	for( uint32_t i=0 ; i<nParents ; i++ )
		XDR_STREAM( pDevice->writePointerReference( pMCParticle->getParents().at(i) ) )

	int32_t pdg = pMCParticle->getPDG();
	XDR_STREAM( pDevice->write( & pdg ) )

	int32_t genstatus = pMCParticle->getGeneratorStatus();
	XDR_STREAM( pDevice->write( & genstatus ) )

	int32_t simstatus = pMCParticle->getSimulatorStatus();
	XDR_STREAM( pDevice->write( & simstatus ) )

	XDR_STREAM( pDevice->writeArray( pMCParticle->getVertex() , 3 ) )

	float time = pMCParticle->getTime();
	XDR_STREAM( pDevice->write( & time ) )

	XDR_STREAM( pDevice->writeArray( pMCParticle->getMomentum() , 3 ) )

	float mass = pMCParticle->getMass();
	XDR_STREAM( pDevice->write( & mass ) )

	float charge = pMCParticle->getCharge();
	XDR_STREAM( pDevice->write( & charge ) )

	if( pMCParticle->getSimulatorStatus() & ( 1 << EVENT::MCParticle::BITEndpoint ) )
		XDR_STREAM( pDevice->writeArray( pMCParticle->getEndpoint() , 3 ) )

	XDR_STREAM( pDevice->writeArray( pMCParticle->getSpin() , 3 ) )
	XDR_STREAM( pDevice->writeArray( pMCParticle->getColorFlow() , 2 ) )

	return xdrstream::XDR_SUCCESS;
}

//----------------------------------------------------------------------------------------------------

xdrstream::Status MCParticleHandler::restoreDaughterParentRelationShip(const EVENT::LCEvent *const pLCEvent)
{
	for(uint32_t c=0 ; c<pLCEvent->getCollectionNames()->size() ; c++ )
	{
		EVENT::LCCollection *pLCCollection = pLCEvent->getCollection( pLCEvent->getCollectionNames()->at( c ) );

		if( pLCCollection->getTypeName() != EVENT::LCIO::MCPARTICLE )
			continue;

		if( ( pLCCollection->getFlag() & ( 1 << EVENT::LCCollection::BITSubset ) ) )
			continue;

		for( uint32_t i=0 ; i<pLCCollection->getNumberOfElements() ; i++ )
		{
			XdrMCParticle* pMCParticle = dynamic_cast<XdrMCParticle*>( pLCCollection->getElementAt(i) );

			for( uint32_t j=0 ; j<pMCParticle->getParents().size() ; j++ )
			{
				XdrMCParticle* pMCParticleParent = dynamic_cast<XdrMCParticle*>( pMCParticle->getParents().at(j) );
				pMCParticleParent->_daughters.push_back( pMCParticle );
			}
		}
	}

	return xdrstream::XDR_SUCCESS;
}

} 

